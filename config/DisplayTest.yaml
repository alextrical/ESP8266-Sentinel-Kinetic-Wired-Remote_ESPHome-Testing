substitutions:
  backlight_delay: "1"  # Backlight odd delay in seconds
  
esphome:
  name: display-test
  includes:
    - custom_lambdas.h
  on_boot:
    then:
      - lambda: |-
          id(boot_time) = millis();
          // Send the 8-byte array over UART
          id(uart_bus).write_array(id(alive_str), 8);
      # - uart.write: !lambda |-
      #     // std::string s = reinterpret_cast<const char*>(id(alive_str));
      #     // return std::vector<unsigned char>( s.begin(), s.end() );
      - delay: ${backlight_delay} s  # delay expects milliseconds
      - binary_sensor.template.publish:
          id: backlight
          state: OFF

esp32:
  variant: esp32s3
  board: esp32-s3-devkitc-1

uart:
  id: uart_bus
  tx_pin: GPIO43
  rx_pin: GPIO44
  baud_rate: 9600

# Example configuration entry
i2c:
  sda: 8
  scl: 9


globals:
  - id: button_sum
    type: int
    initial_value: '0'
  - id: va_out_buff
    type: uint8_t[8]
    initial_value: '{0x04,0x05,0xAF,0xEF,0xFB,0x00,0x00,0x00}'
  - id: alive_str
    type: uint8_t[8]
    initial_value: '{0x04,0x06,0xFF,0xFF,0xFF,0x10,0xFC,0xE8}'
  - id: boot_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

display:
  - platform: lcd_pcf8574
    id: lcd
    dimensions: 16x2
    address: 0x27
    update_interval: 100ms
    lambda: |-
      if (millis() - id(boot_time) < 5000) {
        // Show splash screen for first 5 seconds
        it.print(0, 0, "VENT-AXIA Remote");
        int elapsed_seconds = (millis() - id(boot_time)) / 625;
        String base_string = "V1.0 ESP ";
        String dots = "";
        for (int i = 0; i < elapsed_seconds && i < 7; i++) {
          dots += ".";
        }
        it.print(0, 1, (base_string + dots).c_str());
      } else {
        VentAxiaPacket();
        it.print(0, 0, to_string(id(button_sum)).c_str());
        
        char str[30];
        for (int i=0; i<8; i++) {
          sprintf(str, "%X", id(va_out_buff)[i]); //Convert hex to string
          if (id(va_out_buff)[i]<16) { 
            it.print(i*2,1,"0");  // add leading "0" if needed
            it.print(i*2+1,1,str);
          } else {
            it.print(i*2,1,str);
          }
        }
      }

binary_sensor:
  - platform: gpio
    pin:
      number: 0
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Up"
    on_press:
      - globals.set:
          id: button_sum
          value: !lambda 'return id(button_sum) + 2;'
      - lambda: |-
          VentAxiaSendKeyPress();
      # - uart.write: !lambda |-
      #     std::string s = reinterpret_cast<const char*>(id(va_out_buff));
      #     return std::vector<unsigned char>( s.begin(), s.end() );
      - binary_sensor.template.publish:
          id: backlight
          state: ON
    on_release:
      - lambda: |-
          VentAxiaSendKeyPress();
      # - uart.write: !lambda |-
      #     std::string s = reinterpret_cast<const char*>(id(va_out_buff));
      #     return std::vector<unsigned char>( s.begin(), s.end() );
      - globals.set:
          id: button_sum
          value: !lambda 'return (id(button_sum) >= 2) ? (id(button_sum) - 2) : 0;'
      - if:
          condition:
            lambda: 'return id(button_sum) == 0;'
          then:
            - binary_sensor.template.publish:
                id: backlight
                state: OFF
  - platform: gpio
    pin:
      number: 12
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Down"
    on_press:
      - globals.set:
          id: button_sum
          value: !lambda 'return id(button_sum) + 1;'
      - lambda: |-
          VentAxiaSendKeyPress();
      # - uart.write: !lambda |-
      #     std::string s = reinterpret_cast<const char*>(id(va_out_buff));
      #     return std::vector<unsigned char>( s.begin(), s.end() );
      - binary_sensor.template.publish:
          id: backlight
          state: ON
    on_release:
      - lambda: |-
          VentAxiaSendKeyPress();
      # - uart.write: !lambda |-
      #     std::string s = reinterpret_cast<const char*>(id(va_out_buff));
      #     return std::vector<unsigned char>( s.begin(), s.end() );
      - globals.set:
          id: button_sum
          value: !lambda 'return (id(button_sum) >= 1) ? (id(button_sum) - 1) : 0;'
      - if:
          condition:
            lambda: 'return id(button_sum) == 0;'
          then:
            - binary_sensor.template.publish:
                id: backlight
                state: OFF
  - platform: gpio
    pin:
      number: 13
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Main"
    on_press:
      - globals.set:
          id: button_sum
          value: !lambda 'return id(button_sum) + 8;'
      - lambda: |-
          VentAxiaSendKeyPress();
      # - uart.write: !lambda |-
      #     std::string s = reinterpret_cast<const char*>(id(va_out_buff));
      #     return std::vector<unsigned char>( s.begin(), s.end() );
      - binary_sensor.template.publish:
          id: backlight
          state: ON
    on_release:
      - lambda: |-
          VentAxiaSendKeyPress();
      # - uart.write: !lambda |-
      #     std::string s = reinterpret_cast<const char*>(id(va_out_buff));
      #     return std::vector<unsigned char>( s.begin(), s.end() );
      - globals.set:
          id: button_sum
          value: !lambda 'return (id(button_sum) >= 8) ? (id(button_sum) - 8) : 0;'
      - if:
          condition:
            lambda: 'return id(button_sum) == 0;'
          then:
            - binary_sensor.template.publish:
                id: backlight
                state: OFF
  - platform: gpio
    pin:
      number: 14
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Set"
    on_press:
      - globals.set:
          id: button_sum
          value: !lambda 'return id(button_sum) + 4;'
      - lambda: |-
          VentAxiaSendKeyPress();
      # - uart.write: !lambda |-
      #     std::string s = reinterpret_cast<const char*>(id(va_out_buff));
      #     return std::vector<unsigned char>( s.begin(), s.end() );
      - binary_sensor.template.publish:
          id: backlight
          state: ON
    on_release:
      - lambda: |-
          VentAxiaSendKeyPress();
      # - uart.write: !lambda |-
      #     std::string s = reinterpret_cast<const char*>(id(va_out_buff));
      #     return std::vector<unsigned char>( s.begin(), s.end() );
      - globals.set:
          id: button_sum
          value: !lambda 'return (id(button_sum) >= 4) ? (id(button_sum) - 4) : 0;'
      - if:
          condition:
            lambda: 'return id(button_sum) == 0;'
          then:
            - binary_sensor.template.publish:
                id: backlight
                state: OFF

  - platform: template
    id: backlight
    filters:
      - delayed_off: ${backlight_delay} s  # delay expects milliseconds
    on_press:
      then:
        - lambda: |-
            id(lcd).backlight();
    on_release:
      then:
        - lambda: |-
            id(lcd).no_backlight();