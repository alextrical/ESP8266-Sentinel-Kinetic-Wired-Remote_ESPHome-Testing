substitutions:
  backlight_delay: "10"  # Backlight odd delay in seconds
  
esphome:
  name: display-test
  on_boot:
    then:
      - switch.toggle: alive
      - lambda: 'id(boot_time) = millis();'
      - binary_sensor.template.publish:
          id: backlight
          state: OFF

esp32:
  variant: esp32s3
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

logger:
  level: NONE #Dissable logs on UART
  # deassert_rts_dtr: true
  hardware_uart : UART0
#   level: DEBUG
#   logs:
#     component: ERROR

uart:
  id: uart_bus
  tx_pin: GPIO1
  rx_pin: GPIO2
  baud_rate: 9600

# External component for UART data processing
external_components:
  - source: github://eigger/espcomponents@latest
    components: [ uartex ]
    refresh: always

uartex:
  rx_timeout: 10ms
  rx_header: [0x02, 0x00]  # Header included in checksum
  rx_checksum2: !lambda |-
    uint16_t crc = 0xFFFF - 0x02;
    for (int i = 0; i < len; i++) crc -= data[i];
    return { static_cast<uint8_t>(crc >> 8), static_cast<uint8_t>(crc) };
  tx_delay: 10ms
  tx_checksum2: !lambda |-
    uint16_t crc = 0xFFFF;
    for (int i = 0; i < len; i++) crc -= data[i];
    return { static_cast<uint8_t>(crc >> 8), static_cast<uint8_t>(crc) };

globals:
  - id: button_sum
    type: int
    initial_value: '0'
  - id: boot_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

i2c:
  sda: 8
  scl: 9
  scan: false

display:
  - platform: lcd_pcf8574
    id: lcd
    dimensions: 16x2
    address: 0x27
    update_interval: 100ms
    lambda: |-
      if (millis() - id(boot_time) < 5000) {
        // Show splash screen for first 5 seconds
        it.print(0, 0, "VENT-AXIA Remote");
        int elapsed_seconds = (millis() - id(boot_time)) / (5000/8);
        std::string base_string = "V1.0 ESP ";
        std::string dots = "";
        for (int i = 0; i < elapsed_seconds && i < 7; i++) {
          dots += ".";
        }
        it.print(0, 1, (base_string + dots).c_str());
      } else { // Print to LCD
        it.printf(0, 0, "%s", id(line1).state.c_str());
        it.printf(0, 1, "%s", id(line2).state.c_str());
      }

text_sensor:
  - platform: uartex
    name: "Line1"
    id: "line1"
    lambda: 'return std::string(reinterpret_cast<const char*>(data + 4), 16);'
  - platform: uartex
    name: "Line2"
    id: "line2"
    lambda: 'return std::string(reinterpret_cast<const char*>(data + 21), 16);'

binary_sensor:
  - platform: gpio
    filters:
      - delayed_on_off: 10ms
    pin:
      number: 0
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Up"
    on_press:
      then:
        - lambda: 'id(button_sum) += 2;'
        - switch.toggle: send
    on_release:
      then:
        - switch.toggle: send
        - lambda: 'id(button_sum) = max(id(button_sum) - 2, 0);'  #Subtract 2 but never go below 0
  - platform: gpio
    filters:
      - delayed_on_off: 10ms
    pin:
      number: 12
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Down"
    on_press:
      then:
        - lambda: 'id(button_sum) += 1;'
        - switch.toggle: send
    on_release:
      then:
        - switch.toggle: send
        - lambda: 'id(button_sum) = max(id(button_sum) - 1, 0);'  #Subtract 1 but never go below 0
  - platform: gpio
    filters:
      - delayed_on_off: 10ms
    pin:
      number: 14
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Set"
    on_press:
      then:
        - lambda: 'id(button_sum) += 4;'
        - switch.toggle: send
    on_release:
      then:
        - switch.toggle: send
        - lambda: 'id(button_sum) = max(id(button_sum) - 4, 0);'  #Subtract 4 but never go below 0
  - platform: gpio
    filters:
      - delayed_on_off: 10ms
    pin:
      number: 13
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Main"
    on_press:
      then:
        - lambda: 'id(button_sum) += 8;'
        - switch.toggle: send
    on_release:
      then:
        - switch.toggle: send
        - lambda: 'id(button_sum) = max(id(button_sum) - 8, 0);'  #Subtract 8 but never go below 0

            
      # - binary_sensor.template.publish:
      #     id: backlight
      #     state: ON

      # - if:
      #     condition:
      #       lambda: 'return id(button_sum) == 0;'
      #     then:
      #       - binary_sensor.template.publish:
      #           id: backlight
      #           state: OFF

  - platform: template
    id: backlight
    filters:
      - delayed_off: ${backlight_delay} s  # delay expects milliseconds
    on_press:
      lambda: 'id(lcd).backlight();'
    on_release:
      lambda: 'id(lcd).no_backlight();'

switch:
  - platform: uartex
    id: send
    command_on: !lambda |-
      return {0x04, 0x05, 0xAF, 0xEF, 0xFB, id(button_sum)};
    command_off: !lambda |-
      return {0x04, 0x05, 0xAF, 0xEF, 0xFB, id(button_sum)};
  - platform: uartex
    id: alive
    command_on: !lambda |-
      return {0x04, 0x06, 0xFF, 0xFF, 0xFF, 0x10};