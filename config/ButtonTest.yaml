esphome:
  name: display-test

esp32:
  variant: esp32s3
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

logger:
  # level: NONE #Dissable logs on UART
  # deassert_rts_dtr: true
  hardware_uart : UART0
#   level: DEBUG
#   logs:
#     component: ERROR

uart:
  id: uart_bus
  tx_pin: GPIO1
  rx_pin: GPIO2
  baud_rate: 9600

# External component for UART data processing
external_components:
  - source: github://eigger/espcomponents@latest
    components: [ uartex ]
    refresh: always

uartex:
  rx_timeout: 10ms
  rx_header: [0x02, 0x00]  # Header included in checksum
  rx_checksum2: !lambda |-
    uint16_t crc = 0xFFFF - 0x02;
    for (int i = 0; i < len; i++) crc -= data[i];
    return { static_cast<uint8_t>(crc >> 8), static_cast<uint8_t>(crc) };
  tx_delay: 10ms

# globals:
#   - id: button_sum
#     type: int
#     initial_value: '0'
#   - id: up
#     type: int
#     initial_value: '0'
#   - id: down
#     type: int
#     initial_value: '0'
#   - id: set
#     type: int
#     initial_value: '0'
#   - id: M
#     type: int
#     initial_value: '0'

interval:
  - interval: 26ms
    then:
      - if:
          condition:
            lambda: 'return id(bitfield_sensor).state > 0;'
          then:
            - switch.toggle: send
          #   - binary_sensor.template.publish:
          #       id: backlight
          #       state: ON
          # else:
          #   - binary_sensor.template.publish:
          #       id: backlight
          #       state: OFF

# 1. Define your 4 binary sensors (GPIO inputs)
binary_sensor:
  - platform: gpio
    id: bit0
    pin:
      number: 12
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Bit 0 (LSB)"
  - platform: gpio
    id: bit1
    pin:
      number: 0
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Bit 1"
  - platform: gpio
    id: bit2
    pin:
      number: 14
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Bit 2"
  - platform: gpio
    id: bit3
    pin:
      number: 13
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Bit 3 (MSB)"

# 2. Create a 4-bit value using binary_sensor_map
sensor:
  - platform: binary_sensor_map
    id: bitfield_sensor
    name: "4-Bit Value"
    type: SUM
    channels:
      - binary_sensor: bit0
        value: 1  # 2^0
      - binary_sensor: bit1
        value: 2  # 2^1
      - binary_sensor: bit2
        value: 4  # 2^2
      - binary_sensor: bit3
        value: 8  # 2^3

switch:
  - platform: uartex
    id: send
    command_on: !lambda |-
      return {0x04, 0x05, 0xAF, 0xEF, 0xFB, id(bitfield_sensor).state};
    command_off: !lambda |-
      return {0x04, 0x05, 0xAF, 0xEF, 0xFB, id(bitfield_sensor).state};
  - platform: uartex
    id: alive
    command_on: !lambda |-
      return {0x04, 0x06, 0xFF, 0xFF, 0xFF, 0x10};